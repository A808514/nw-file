# print ("......" []) تستخدم لمعرفة ترتيب الحرف المراد معرفته
# Str() String تستخدم لتحويل اي شئ الي
# Type() تسخدم لمعرفة نوع البيانات
# len() :  تستخدم لمعرفة طول النص او عدد خانات النص
# 5 ** 6 دي معناها خمسة اس ستة
# ( // ) دي بتطلع ناتج القسمة منغير ارقام عشرية
# ( / ) دي بتطلع ناتج القسمة بارقام عشرية
# ( % )  دي بتطلع الباقي من ناتج القسمة او الزيادة اللي في الرقم
# (f".......{}") دي بتحولك او بتنسقلك اي كود اوتوماتيك الي النوع المناسب منغير ما انت تحوله
# ( != ) دي معناها لا يساوي
# ( or ) تقدر تستخدمها عشان تتحقق كذا شرط في نفس الوقت
# ( and ) تستخدم لتحقيق جميع الشروط في نفس الوقت
# ("""........""") تقدر تستخدمها عشان تكتب كذا سطر في نفس الوقت بدل ما تطبع كذا امر طباعة
# Module : هي دي الادوات
# Library : هي دي المكتبة اللي فيها الادوات
# Freamwork : هو ده اطار العمل اللي جواه المكتبات اللي فيها الادوات
# (import.module) or (import.file) :أو لربط الملفات ببعضها لو انت عامل كذا ملف Modules بستخدمها عشان استخرج ال
# Random : بستخدمها عشان اختار اي حاجة عشوائية Module دي عبارة عن
# [".....", ".....", ".....", "....."] list دي عبارة عن قائمة اسمها
# Variable.append() : بستخدمها عشان اضيف عنصر للقائمة
# Variable.extend() : بستخدمها عشان اضيف عناصر قائمة لقائمة اخري
# Variable.remove() : بستخدمها عشان احذف عنصر من القائمة
# ( In ) : بستخدمها عشان اتحقق من وجود عنصر في القائمة
#  Random.choice() : عشان يختار عشوائي بين عناصر او نصوص
# (for variable2 in variable1 : ) Variable 1 للعناصر اللي موجودة في Variable 2 وده بيخزن ال لوب في المتغير loop دي بستخدمها عشان اعمل
# (for varrable in range()): دي بستخدمها عشان التكرار للعدد اللي انا عاوزه
# sum () : دي بستخدمها عشان اجمع كل حاجة في نفس القائمة
# ("".join(variable)) : دي بستخدمها عشان اضيف اي حاجة بين الحاجات اللي موجودة في المتغير سواء نصوص او كلمات
# (While شرط : ) : دي بستخدمها عشان اكرر عدد لا نهائي طول ما الشرط متحقق ولو الشرط متحققش اللوب مش هيتنفذ والبرنامج هيفضل شغال طول مالشرط متحقق
# ( if i % 2 != 0 ) الشرط ده لو عاوز تطبع الارقام الفردية بس
# ( if i % 2 == 0 ) الشرط ده لو عاوز تطبع الارقام الزوجية بس
# list :  عبارة عن مجموعة مرتبة وقابلة للتغيير. يسمح بأعضاء مكررة.
# Tuple : عبارة عن مجموعة مرتبة وغير قابلة للتغيير. يسمح بأعضاء مكررة.
# Set : عبارة عن مجموعة غير مرتبة وغير قابلة للتغيير وغير مفهرسة. لا يوجد أعضاء مكررة.
# Dictionary : عبارة عن مجموعة مرتبة وقابلة للتغيير. لا يوجد أعضاء مكررة
# isdigit() : تستخدم للتحقق من الارقام
# os : عشان اتعامل مع انظمة التشغيل Module دي عبارة عن
# os.mkdir("name_file") : بستخدمها عشان أنشئ ملف جديد
# os.system("Command") : تستخدم للدخول علي النظام و كتابة الأمر المراد تنفيذه
# os.system("clear") : تستخدم لمسح الشاشة مع انظمة التشغيل لينكس و ابل
# os.system("cls") : تستخدم لمسح الشاشة مع جميع انظمة التشغيل الأخري
# os.name("اسم نظام التشغيل") : ("posix") لو اي نظام تشغيل امل لو لينكس و ابل هتكتب ("nt") تكتب
# os.name : لمعرفة نظام التشغيل الخاص بك
# return : بستخدمها عشان اخزن اي اجة اكتبها في الفانكيشن
# golbal : تستخدم في الفانكيشن للتعامل مع المتغير العام و ليس المتغير الموجود بداخل الفانكيشن بيحث يمكنكك وده تقدر تستخدمه لو عوزت تغير اي ثابت عندك
# help(module) : بتعرفك كل حاجة عن المكتبة
# count() : بستخدمها عشان اعرف العنصر متكرر كام مرة في القائمة
# list() : بستخدمها عشان اجمع العناصر في قائمة
# zip() : بتجمعلك كل عنصر من القائمة الاولي مع القائمة التانية وممكن اكتر من قائمة عادي
# enumerate(iterable, start) : بترجع كل عنصر في القائمة مع المكان اللي انت عاوز تبدأ من عنده ولو محددتش البداية هو اتوماتيك هيبدأ من ال 0
# set.discard(): remove بتحذف العنصر من السيت عادي بس لو العنصر مش موجود مبيعملش ايرور وده بيميزه عن
# set.remove(): بتحذف العنصر من السيت بس لو مش موجود بيديك ايرور
# set.del(): بيحذف كل العناصر الي في السيت
# random.shuffle(): بستخدمها عشان اوزع العناصر توزيع عشوائي جوة القائمة
# random.sample(): بستخدمها عشان اختار عدد عشاوائي من العناصر من القائمة
# random.randrange(): بتختار عنصر عشوائي من بين العنصرين اللي بتحطهم
# random.seed(): بتثبتلي قيمة العنصر العشوائي اللي بيطلع
# open(file) : تستخدم لفتح الملفات
# lambda : Useful for creating one-liner functions.
# map(func, *iterables) : Transforms all elements in an iterable.
# filter() : Selects elements from an iterable based on a condition.
# def name of the function (*args) :  ممكن تحط عدد لا نهائي من المتغيرات اللي انت عاوزه جوة الفانكيشن
# def name of the function (**args) : it can accept a variable number of keyword arguments as a dictionary.
# abs() : to convert the number from negative to positive
# swapcase() : to swap the capital letters with small and the opposite is correct

# __________________________________________________________________________________#

# ( Math Module ) you can use for mathematical tasks.

# math.acos() 	Returns the arc cosine of a number
# math.acosh() 	Returns the inverse hyperbolic cosine of a number
# math.asin() 	Returns the arc sine of a number
# math.asinh() 	Returns the inverse hyperbolic sine of a number
# math.atan() 	Returns the arc tangent of a number in radians
# math.atan2() 	Returns the arc tangent of y/x in radians
# math.atanh() 	Returns the inverse hyperbolic tangent of a number
# math.ceil() 	Rounds a number up to the nearest integer
# math.comb() 	Returns the number of ways to choose k items from n items without repetition and order
# math.copysign() 	Returns a float consisting of the value of the first parameter and the sign of the second parameter
# math.cos() 	Returns the cosine of a number
# math.cosh() 	Returns the hyperbolic cosine of a number
# math.degrees() 	Converts an angle from radians to degrees
# math.dist() 	Returns the Euclidean distance between two points (p and q), where p and q are the coordinates of that point
# math.erf() 	Returns the error function of a number
# math.erfc() 	Returns the complementary error function of a number
# math.exp() 	Returns E raised to the power of x
# math.expm1() 	Returns Ex - 1
# math.fabs() 	Returns the absolute value of a number
# math.factorial() 	Returns the factorial of a number
# math.floor() 	Rounds a number down to the nearest integer
# math.fmod() 	Returns the remainder of x/y
# math.frexp() 	Returns the mantissa and the exponent, of a specified number
# math.fsum() 	Returns the sum of all items in any iterable (tuples, arrays, lists, etc.)
# math.gamma() 	Returns the gamma function at x
# math.gcd() 	Returns the greatest common divisor of two integers
# math.hypot() 	Returns the Euclidean norm
# math.isclose() 	Checks whether two values are close to each other, or not
# math.isfinite() 	Checks whether a number is finite or not
# math.isinf() 	Checks whether a number is infinite or not
# math.isnan() 	Checks whether a value is NaN (not a number) or not
# math.isqrt() 	Rounds a square root number downwards to the nearest integer
# math.ldexp() 	Returns the inverse of math.frexp() which is x * (2**i) of the given numbers x and i
# math.lgamma() 	Returns the log gamma value of x
# math.log() 	Returns the natural logarithm of a number, or the logarithm of number to base
# math.log10() 	Returns the base-10 logarithm of x
# math.log1p() 	Returns the natural logarithm of 1+x
# math.log2() 	Returns the base-2 logarithm of x
# math.perm() 	Returns the number of ways to choose k items from n items with order and without repetition
# math.pow() 	Returns the value of x to the power of y
# math.prod() 	Returns the product of all the elements in an iterable
# math.radians() 	Converts a degree value into radians
# math.remainder() 	Returns the closest value that can make numerator completely divisible by the denominator
# math.sin() 	Returns the sine of a number
# math.sinh() 	Returns the hyperbolic sine of a number
# math.sqrt() 	Returns the square root of a number
# math.tan() 	Returns the tangent of a number
# math.tanh() 	Returns the hyperbolic tangent of a number
# math.trunc() 	Returns the truncated integer parts of a number

# math.e 	Returns Euler's number (2.7182...)
# math.inf 	Returns a floating-point positive infinity
# math.nan 	Returns a floating-point NaN (Not a Number) value
# math.pi 	Returns PI (3.1415...)
# math.tau 	Returns tau (6.2831...)

# __________________________________________________________________________________#

# ( cmath Module) you can use for mathematical tasks for complex numbers.

# cmath.acos(x) 	Returns the arc cosine value of x
# cmath.acosh(x) 	Returns the hyperbolic arc cosine of x
# cmath.asin(x) 	Returns the arc sine of x
# cmath.asinh(x) 	Returns the hyperbolic arc sine of x
# cmath.atan(x) 	Returns the arc tangent value of x
# cmath.atanh(x) 	Returns the hyperbolic arctangent value of x
# cmath.cos(x) 	Returns the cosine of x
# cmath.cosh(x) 	Returns the hyperbolic cosine of x
# cmath.exp(x) 	Returns the value of Ex, where E is Euler's number (approximately 2.718281...), and x is the number passed to it
# cmath.isclose() 	Checks whether two values are close, or not
# cmath.isfinite(x) 	Checks whether x is a finite number
# cmath.isinf(x) 	Check whether x is a positive or negative infinty
# cmath.isnan(x) 	Checks whether x is NaN (not a number)
# cmath.log(x[, base]) 	Returns the logarithm of x to the base
# cmath.log10(x) 	Returns the base-10 logarithm of x
# cmath.phase() 	Return the phase of a complex number
# cmath.polar() 	Convert a complex number to polar coordinates
# cmath.rect() 	Convert polar coordinates to rectangular form
# cmath.sin(x) 	Returns the sine of x
# cmath.sinh(x) 	Returns the hyperbolic sine of x
# cmath.sqrt(x) 	Returns the square root of x
# cmath.tan(x) 	Returns the tangent of x
# cmath.tanh(x) 	Returns the hyperbolic tangent of x

# cmath.e 	Returns Euler's number (2.7182...)
# cmath.inf 	Returns a floating-point positive infinity value
# cmath.infj 	Returns a complex infinity value
# cmath.nan 	Returns floating-point NaN (Not a Number) value
# cmath.nanj 	Returns coplext NaN (Not a Number) value
# cmath.pi 	Returns PI (3.1415...)
# cmath.tau 	Returns tau (6.2831...)

# __________________________________________________________________________________#

# ( statistics Module) you can use to calculate mathematical statistics of numeric data.

# statistics.harmonic_mean() 	Calculates the harmonic mean (central location) of the given data
# statistics.mean() 	Calculates the mean (average) of the given data
# statistics.median() 	Calculates the median (middle value) of the given data
# statistics.median_grouped() 	Calculates the median of grouped continuous data
# statistics.median_high() 	Calculates the high median of the given data
# statistics.median_low() 	Calculates the low median of the given data
# statistics.mode() 	Calculates the mode (central tendency) of the given numeric or nominal data
# statistics.pstdev() 	Calculates the standard deviation from an entire population
# statistics.stdev() 	Calculates the standard deviation from a sample of data
# statistics.pvariance() 	Calculates the variance of an entire population
# statistics.variance() 	Calculates the variance from a sample of data

# __________________________________________________________________________________#

# ( copy Module )

# copy.copy() : تقدر تستخدمه لو انت عاوز تنسخ حاجة من متغير منغير ماتاخد الحاجة وتحطها فتنسخ المحتوي بتاع المتغير علي طول ولو عدلت في الحاجة دي التعديل هيتطبق علي النسخ اللي انت خدته
# copy.deepcopy() : هو هو بس لما تعدل التعديل مش هيتطبق علي المتغير اللي انت ناسخ فيه هيتطبق علي الاصلي بس

# __________________________________________________________________________________#

#  ( pickle Module )

# pickle.dump(obj, file, protocol=None) : Serializes obj and writes it to a binary file-like object.
# pickle.load(file) : Reads a pickled object from a binary file-like object and returns it.
# pickle.dumps(obj, protocol=None) : Serializes obj into a byte string.
# pickle.loads(bytes_obj) : Deserializes a byte string back into a Python object.

# __________________________________________________________________________________#

#  ( functools Module )

# functools.partial : Creates partial functions by pre-filling arguments.
# functools.reduce : Reduces an iterable to a single value using a function.
# functools.lru_cache :	Adds memoization to functions.
# functools.singledispatch : Creates generic functions with type-based dispatch.
# functools.wraps :	Preserves metadata for decorated functions.
# functools.total_ordering : Simplifies comparison method implementation.
# functools.cached_property : Caches property results for optimization.

# __________________________________________________________________________________#

# ( Numpy Library )

# Array Manipulation

#     numpy.reshape(): Change the shape of an array.
#     numpy.ravel(): Flatten an array.
#     numpy.transpose(): Transpose an array.
#     numpy.swapaxes(): Swap two axes of an array.
#     numpy.concatenate(): Concatenate arrays.
#     numpy.stack(): Stack arrays along a new dimension.
#     numpy.split(): Split an array into multiple sub-arrays.
#     numpy.hstack(): Stack arrays horizontally.
#     numpy.vstack(): Stack arrays vertically.
#     numpy.dstack(): Stack arrays depth-wise.
#     numpy.expand_dims(): Add an axis to an array.
#     numpy.squeeze(): Remove single-dimensional entries.
#     numpy.asarray(): to convert lists to arrays

# Mathematical Operations

#     Element-wise:
#         numpy.add()
#         numpy.subtract()
#         numpy.multiply()
#         numpy.divide()
#         numpy.power()
#         numpy.mod()
#         numpy.remainder()
#     Trigonometric:
#         numpy.sin()
#         numpy.cos()
#         numpy.tan()
#         numpy.arcsin()
#         numpy.arccos()
#         numpy.arctan()
#         numpy.deg2rad()
#         numpy.rad2deg()
#     Exponential & Logarithmic:
#         numpy.exp()
#         numpy.expm1()
#         numpy.log()
#         numpy.log10()
#         numpy.log2()
#         numpy.log1p()
#     Rounding:
#         numpy.around()
#         numpy.floor()
#         numpy.ceil()
#         numpy.trunc()
#     Statistical:
#         numpy.mean()
#         numpy.median()
#         numpy.std()
#         numpy.var()
#         numpy.min()
#         numpy.max()
#         numpy.sum()
#         numpy.prod()
#         numpy.percentile()
#         numpy.quantile()

# Linear Algebra

#     numpy.dot(): Dot product of two arrays.
#     numpy.matmul(): Matrix multiplication.
#     numpy.linalg.inv(): Compute the inverse of a matrix.
#     numpy.linalg.det(): Compute the determinant of a matrix.
#     numpy.linalg.eig(): Compute the eigenvalues and eigenvectors.
#     numpy.linalg.qr(): Compute the QR decomposition.
#     numpy.linalg.svd(): Compute the Singular Value Decomposition.
#     numpy.linalg.solve(): Solve a linear matrix equation.
#     numpy.linalg.norm(): Compute vector/matrix norm.

# Fourier Transform

#     numpy.fft.fft(): Compute the one-dimensional Fourier Transform.
#     numpy.fft.ifft(): Compute the inverse one-dimensional Fourier Transform.
#     numpy.fft.fft2(): Compute the two-dimensional Fourier Transform.
#     numpy.fft.ifft2(): Compute the inverse two-dimensional Fourier Transform.
#     numpy.fft.fftn(): Compute the N-dimensional Fourier Transform.

# Random Number Generation

#     numpy.random.seed(): Seed the random number generator.
#     numpy.random.rand(): Generate random numbers in a uniform distribution.
#     numpy.random.randn(): Generate random numbers in a standard normal distribution.
#     numpy.random.randint(): Generate random integers.
#     numpy.random.choice(): Randomly select elements from an array.

# Array Analysis

#     numpy.unique(): Find unique elements in an array.
#     numpy.where(): Return indices satisfying a condition.
#     numpy.nonzero(): Return indices of non-zero elements.
#     numpy.count_nonzero(): Count non-zero elements.
#     numpy.any(): Test whether any elements evaluate to True.
#     numpy.all(): Test whether all elements evaluate to True.

# Sorting and Searching

#     numpy.sort(): Sort an array.
#     numpy.argsort(): Indices of the sorted elements.
#     numpy.searchsorted(): Find indices where elements should be inserted to maintain order.

# I/O

#     numpy.save(): Save an array to a binary file.
#     numpy.load(): Load an array from a binary file.
#     numpy.savetxt(): Save an array to a text file.
#     numpy.loadtxt(): Load data from a text file.

# Broadcasting and Advanced Indexing

#     numpy.meshgrid(): Generate coordinate matrices.
#     numpy.ix_(): Construct index arrays for advanced indexing.
#     numpy.broadcast_to(): Broadcast an array to a new shape.
#     numpy.take(): Take elements from an array along an axis.

# Masked Arrays

#     numpy.ma.masked_where(): Mask array elements based on a condition.
#     numpy.ma.filled(): Replace masked elements with a specified value.

# __________________________________________________________________________________#

# ( Matplotlib Library )

# plt.plot() : is use to make line
# plt.scatter() : is use to make points

# __________________________________________________________________________________#

# ( Pandas Library )

# 1. Data Creation and Input

#     pandas.read_csv()
#     pandas.read_excel()
#     pandas.read_sql()
#     pandas.read_sql_query()
#     pandas.read_sql_table()
#     pandas.read_json()
#     pandas.read_html()
#     pandas.read_clipboard()
#     pandas.read_feather()
#     pandas.read_parquet()
#     pandas.read_pickle()
#     pandas.read_stata()
#     pandas.read_sas()
#     pandas.read_table()
#     pandas.read_orc()
#     pandas.DataFrame()
#     pandas.Series()

# 2. Data Export

#     DataFrame.to_csv()
#     DataFrame.to_excel()
#     DataFrame.to_json()
#     DataFrame.to_html()
#     DataFrame.to_sql()
#     DataFrame.to_pickle()
#     DataFrame.to_clipboard()
#     DataFrame.to_feather()
#     DataFrame.to_parquet()
#     DataFrame.to_stata()

# 3. Data Selection and Indexing

#     DataFrame.loc[]
#     DataFrame.iloc[]
#     DataFrame.at[]
#     DataFrame.iat[]
#     DataFrame.lookup()
#     DataFrame.xs()
#     DataFrame.query()
#     DataFrame.filter()

# 4. Data Manipulation
# Sorting

#     DataFrame.sort_values()
#     DataFrame.sort_index()

# Aggregation

#     DataFrame.agg()
#     DataFrame.aggregate()

# Applying Functions

#     DataFrame.apply()
#     DataFrame.applymap()
#     Series.map()

# Pivoting and Reshaping

#     DataFrame.pivot()
#     DataFrame.pivot_table()
#     DataFrame.melt()
#     DataFrame.stack()
#     DataFrame.unstack()
#     DataFrame.explode()

# Combining and Merging

#     pandas.merge()
#     pandas.concat()
#     DataFrame.append()
#     pandas.join()

# Replacement

#     DataFrame.replace()

# Filling Missing Data

#     DataFrame.fillna()
#     DataFrame.interpolate()

# Dropping

#     DataFrame.drop()
#     DataFrame.dropna()

# Duplicates

#     DataFrame.duplicated()
#     DataFrame.drop_duplicates()

# Renaming

#     DataFrame.rename()

# Reindexing

#     DataFrame.reindex()
#     DataFrame.reindex_like()

# 5. Descriptive Statistics

#     DataFrame.describe()
#     DataFrame.mean()
#     DataFrame.median()
#     DataFrame.mode()
#     DataFrame.std()
#     DataFrame.var()
#     DataFrame.sum()
#     DataFrame.cumsum()
#     DataFrame.prod()
#     DataFrame.cumprod()
#     DataFrame.min()
#     DataFrame.max()
#     DataFrame.idxmin()
#     DataFrame.idxmax()
#     DataFrame.count()
#     DataFrame.corr()
#     DataFrame.cov()
#     DataFrame.skew()
#     DataFrame.kurt()

# 6. String Operations

#     Series.str.contains()
#     Series.str.len()
#     Series.str.replace()
#     Series.str.lower()
#     Series.str.upper()
#     Series.str.strip()
#     Series.str.split()
#     Series.str.cat()
#     Series.str.extract()
#     Series.str.extractall()
#     Series.str.startswith()
#     Series.str.endswith()
#     Series.str.find()

# 7. Time Series

#     pandas.date_range()
#     pandas.to_datetime()
#     pandas.to_timedelta()
#     DataFrame.asfreq()
#     DataFrame.resample()
#     DataFrame.shift()
#     DataFrame.tshift()
#     DataFrame.rolling()
#     DataFrame.expanding()
#     DataFrame.ewm()

# 8. Missing Data Handling

#     DataFrame.isna()
#     DataFrame.notna()
#     DataFrame.fillna()
#     DataFrame.dropna()
#     DataFrame.interpolate()

# 9. File Operations

#     pandas.get_dummies()
#     pandas.factorize()
#     DataFrame.astype()
#     DataFrame.infer_objects()

# 10. Plotting

#     DataFrame.plot()
#     DataFrame.hist()
#     DataFrame.boxplot()
#     DataFrame.scatter()

# 11. Utility Functions

#     DataFrame.info()
#     DataFrame.shape
#     DataFrame.dtypes
#     DataFrame.empty
#     DataFrame.ndim
#     DataFrame.memory_usage()

# __________________________________________________________________________________#

# -----------------------------------------------------------------

# zip() : بتجمعلك كل عنصر من القائمة الاولي مع القائمة التانية وممكن اكتر من قائمة عادي

# # Example lists
# list1 = [1, 2, 3]
# list2 = ['a', 'b', 'c']
# list3 = ["10" , "20", "30"]

# # Zipping the lists
# print(zip(list1, list2, list3)) # <zip object at 0x0000017B16048180>
# print(list(zip(list1, list2, list3))) # [(1, 'a', '10'), (2, 'b', '20'), (3, 'c', '30')]
# print(*zip(list1, list2, list3)) # (1, 'a', '10') (2, 'b', '20') (3, 'c', '30')

# -----------------------------------------------------------------

# enumerate(iterable, start) : بترجع كل عنصر في القائمة مع المكان اللي انت عاوز تبدأ من عنده ولو محددتش البداية هو اتوماتيك هيبدأ من ال 0

# lst1 = ["BMW", "Marcedes", "Ferari"]
# x = enumerate(lst1)
# print(*x) # (0, 'BMW') (1, 'Marcedes') (2, 'Ferari')

# aa=[3,5,8]
# bb=[10,20,30]
# y = enumerate(zip(aa,bb),start=1)
# print(*y) # (1, (3, 10)) (2, (5, 20)) (3, (8, 30))

# for ind, (a, b) in y:
#     print('index:',ind, a*b)

# -----------------------------------------------------------------

# Difference between discard() and remove()
# discard(): remove بتحذف العنصر من السيت عادي بس لو العنصر مش موجود مبيعملش ايرور وده بيميزه عن
# remove(): بتحذف العنصر من السيت بس لو مش موجود بيديك ايرور

# # initialize my_set
# my_set = {1, 3, 4, 5, 6}
# print(my_set)

# # add 10 to set
# my_set.add(10)
# print(my_set)

# # discard an element
# my_set.discard(3)
# print(my_set)
# my_set.discard(200)
# print(my_set)

# # remove an element
# my_set.remove(6)
# print(my_set)

# my_set.remove(600)
# print(my_set)

# -----------------------------------------------------------------

# Python Set Operations

# aa = {1,3,4,7}
# bb = {1,4,7,10,11}

# intersection
# print(aa & bb)
# print(set.intersection(aa, bb))

# # uniion
# print(aa | bb)
# print(set.union(aa, bb))

# # difference
# print(aa - bb)
# print(set.difference(aa, bb))

# # symmetric difference
# print(aa ^ bb)
# print(set.symmetric_difference(aa, bb))

# # subset
# A = {1, 2}
# B = {1, 2, 3}
# print(set.issubset(A, B)) # Output: True

# # Superset
# A = {1, 2, 3}
# B = {1, 2}
# print(set.issuperset(A, B)) # Output: True

# # Disjoint
# A = {1, 2, 3}
# B = {4, 5, 6}
# print(set.isdisjoint(A, B)) # Output: True

# -----------------------------------------------------------------

# # copy.copy()

# import copy

# result_A = [[90, 85, 82],
#             [72, 88, 90]] # Student A grades

# result_B = copy.copy(result_A) # Student B grades (copied from A)

# # Change first year and first subject's marks to 30
# result_B[0][0] = 30

# print("Original List: ")
# print(result_A)
# print("Shallow Copy:")
# print(result_B)

# -----------------------------------------------------------------

# # copy.deepcopy()

# import copy

# result_A = [[90, 85, 82], [72, 88, 90]] # Student A grades
# result_B = copy.deepcopy(result_A) # Student B grades (copied from A)

# # Change first year and first subject's marks to 30
# result_B[0][0] = 120

# print("Original List: ")
# print(result_A)
# print("Deep Copy:")
# print(result_B)

# -----------------------------------------------------------------

# # pickle module

# import pickle

# lst = [10, "ahmed", "abdallah", 40, 50, "hahahaha"]
# file = open("maine", "wb")
# pickle.dump(lst, file)
# file.close()

# file = open("maine", "rb")
# text = pickle.load(file)
# file.close()
# print(text)

# def write_from_file(filename):
#     file = open(filename, "wb")
#     pickle.dump(filename, file)
#     file.close()

# def read_from_file(filename):
#     file = open(filename, "rb")
#     text = pickle.load(file)
#     file.close()
#     return text

# def read_line_by_line(filename):
#     file = open(filename, "r")
#     for line in file :
#         print(line, end = "")
#     file.close()

# def read_word_by_word(filename):
#     file = open(filename, "r")
#     for line in file :
#         for word in line:
#             print(word, end = "")

# -----------------------------------------------------------------

# lambda, map, filter

# x = lambda a,b : a*b
# print(x(5,10))

# lst1 = [10 , 4, 5, 6, 7, 3]
# lst2 = list(map(lambda a : a**2 , lst1))
# print(lst2)

# lst1 = [20 , 45, 5, 10, 7, 3]
# lst2 = list(filter(lambda a : a > 10, lst1))
# print(lst2)

# -----------------------------------------------------------------

# lst = [10 , 4, 5, 6, 7, 3]
# from functools import reduce

# x = reduce(lambda a,b : a*b, lst )
# print(x)

# -----------------------------------------------------------------

# def name of the function (*args)

# def my_sum(*ahmed):
#     result = 0
#     for x in ahmed:
#         result += x
#     return result

# print(my_sum(1, 2, 3))
# print(my_sum(5,10,15,20,25))

# -----------------------------------------------------------------

# def name of the function (**args)

# def concatenate(**main):
#     result = ""
#     # Iterating over the Python kwargs dictionary
#     for v in main.values():
#         result += v
#     return result

# print(concatenate(a="Real", b="Python", c="Is", d="Great", e="!"))

# -----------------------------------------------------------------

# ( Dealing with Errors )
# We use (try and except)

# import sys

# a=int(input('input first number:'))
# b=int(input('input second number:'))
# try:
#     res=int(a / b)   #A/5  value error
# except ValueError : # to avoid invalid input
#     print("Invalid input")
# except ZeroDivisionError: # to avoid ( divide by zero ) error
#     print('Oops ', sys.exc_info()[0], 'occured') # this code is used to print the error message
#     print('Exception handled')
# else:
#     print(res)
# finally:
#     print('this code will no matter what')

# x = 10
# if x > 5:
#     raise Exception(f'x should not exceed 5. The value of x was: {x}') # ( raise ) is used to this message if error happens

# -----------------------------------------------------------------

# (((((((((((((((( 1. Python Fundamentals )))))))))))))))))))

# a = 4
# b = 2
# try:
#     x = a // b
#     print(x)
# except ZeroDivisionError:
#     print("it is not possible to divide by zero")
# finally:
#     print("done")
# ----------------------------------------------------------------------------------------
# text = "This is a test"
# if text != "test" :
#     raise TypeError("both the strings are different")
# ----------------------------------------------------------------------------------------

# (((((((((((((((( 4. Python Functions )))))))))))))))))))

# def fun(*args):
#     print(sum(args))

# fun(1, 2, 3, 4, 5, 6, 7, 8, 9)

# def fun2(**kwargs):
#     for k, v in kwargs.items():
#         print(k, v)

# fun2(a = 1, b = 2, c = 3)
# ----------------------------------------------------------------------------------------
# lst = [1, 2, 3, 4, 5]
# def fun(value):
#     return(value * 2)


# print(list(map(fun, lst)))
# ----------------------------------------------------------------------------------------

# (((((((((((((((( 5. Python OOPs Concepts )))))))))))))))))))

# class Dog:
#     def __init__(self, name, age):
#         self.name = name
#         self.age = age
#     def __str__(self):
#         return f"{self.name} is {self.age} years old."  # Correct: Returning a string


# dog1 = Dog("Buddy", 3)
# dog2 = Dog("Charlie", 5)


# print(dog1)
# print(dog2)
# ----------------------------------------------------------------------------------------
# class Protected:
#     def __init__(self):
#         self._age = 30  # Protected attribute

# class Subclass(Protected):
#     def display_age(self):
#         print(self._age)  # Accessible in subclass

# obj = Subclass()
# obj.display_age()


# class Private:
#     def __init__(self):
#         self.__salary = 50000  # Private attribute

#     def salary(self):
#         return self.__salary  # Access through public method

# obj = Private()
# print(obj.salary())  # Works
# ----------------------------------------------------------------------------------------
# s = "GFG"
# it = iter(s)

# print(next(it))
# print(next(it))
# print(next(it))

# lst = [100, 200, 300, 400]
# it = iter(lst)
# while True:
#     try:
#         print(next(it))
#     except StopIteration:
#         print("End of iteration")
#         break
# ----------------------------------------------------------------------------------------

# (((((((((((((((( 7. File Handling )))))))))))))))))))

# Mode	Description	Behavior
# r	| Read-only mode.	Opens the file for reading. File must exist; otherwise, it raises an error.
# rb  |	Read-only in binary mode.	Opens the file for reading binary data. File must exist; otherwise, it raises an error.
# r+  |	Read and write mode.	Opens the file for both reading and writing. File must exist; otherwise, it raises an error.
# rb+ |	Read and write in binary mode.	Opens the file for both reading and writing binary data. File must exist; otherwise, it raises an error.
# w	| Write mode.	Opens the file for writing. Creates a new file or truncates the existing file.
# wb   | Write in binary mode.	Opens the file for writing binary data. Creates a new file or truncates the existing file.
# w+ |	Write and read mode.	Opens the file for both writing and reading. Creates a new file or truncates the existing file.
# wb+ |	Write and read in binary mode.	Opens the file for both writing and reading binary data. Creates a new file or truncates the existing file.
# a	 | Append mode.	Opens the file for appending data. Creates a new file if it doesn’t exist.
# ab |	Append in binary mode.	Opens the file for appending binary data. Creates a new file if it doesn’t exist.
# a+ |	Append and read mode.	Opens the file for appending and reading. Creates a new file if it doesn’t exist.
# ab+ |	Append and read in binary mode.	Opens the file for appending and reading binary data. Creates a new file if it doesn’t exist.
# x |	Exclusive creation mode.	Creates a new file. Raises an error if the file already exists.
# xb |	Exclusive creation in binary mode.	Creates a new binary file. Raises an error if the file already exists.
# x+ |	Exclusive creation with read and write mode.	Creates a new file for reading and writing. Raises an error if the file exists.
# xb+ |	Exclusive creation with read and write in binary mode.	Creates a new binary file for reading and writing. Raises an error if the file exists.

# file = open("main.txt", "ab")
# file.write(
#     "When opening a file, we must specify the mode we want to which specifies \nwhat we want to do with the file. Here is a table of the different modes available:"
# )
# file.close()

# with open("main.txt", "r") as file :
#     content = file.read()
#     print (content)

# with open("data.csv", "r") as csvfile :
#     content = csvfile.read()
#     print (content)

# with open("dataj.json", "r") as jsonfile :
#     content = jsonfile.read()
#     print (content)

# ----------------------------------------------------------------------------------------

# import os
# cwd = os.getcwd()
# print("Current working directory:", cwd)

# import os
# def current_path():
#     print("Current working directory before")
#     print(os.getcwd())
#     print()
# current_path()
# os.chdir("../")
# current_path()

# import os
# path = "D:\Progrmming"
# dir_list = os.listdir(path)
# for i in dir_list:
#     print(i)

# import os
# directory = "geeks.venv"
# dir_parent = "D:\Progrmming"
# path = os.path.join(dir_parent, directory)
# os.mkdir(path)
# print(f"Directory {directory} Created")

# ----------------------------------------------------------------------------------------

# from collections import Counter

# lst1 = [1, 2, 2, 3, 3, 3, 4]
# lst2 = [1, 1, 2, 3, 3, 4, 4, 4]

# word = "Abdallah"
# ctr1 = Counter(lst1)
# ctr2 = Counter(lst2)

# print(ctr1)

# print(list(ctr1.elements()))

# ctr1.update([2, 3, 4, 2])
# print(ctr1)

# print(Counter(word))

# print(ctr1.most_common())
# print(ctr1.most_common(2))

# print(ctr1 + ctr2)
# print(ctr1 - ctr2)
# print(ctr1 & ctr2)
# print(ctr1 | ctr2)

# ----------------------------------------------------------------------------------------

# n = 0
# name = "Ahmed"
# pas = 112412
# while(n < 3):
#     user_name = input("Enter the user name: ")
#     password = int(input("Enter the password: "))

#     if user_name == name and password == pas :
#         print(f"Welcome {user_name}")
#         break
#     else:
#         print("Try again")
#         n += 1
#         continue

# ----------------------------------------------------------------------------------------

# import random

# computer = ["Rock", "Paper", "Scissors"]
# option_of_computer = random.choice(computer)

# user = input("Enter your choice (Rock, Paper, Scissors): ")

# while True:
#     if (
#         (user.lower() == "paper" and option_of_computer.lower() == "rock")
#         or (user.lower() == "rock" and option_of_computer.lower() == "scissors")
#         or (user.lower() == "scissors" and option_of_computer.lower() == "paper")
#     ):
#         print(
#             f"Your Choice is {user.capitalize()} & Computer Choice is {option_of_computer.capitalize()}"
#         )
#         print("User Win")

#         exi = input("Do you want to exit (Yes | NO): ")
#         if exi.lower() == "yes":
#             break
#         else:
#             continue

#     elif (
#         (option_of_computer.lower() == "paper" and user.lower() == "rock")
#         or (option_of_computer.lower() == "rock" and user.lower() == "scissors")
#         or (option_of_computer.lower() == "scissors" and user.lower() == "paper")
#     ):
#         print(
#             f"Your Choice is {user.capitalize()} & Computer Choice is {option_of_computer.capitalize()}"
#         )
#         print("Computer Win")

#         exi = input("Do you want to exit (Yes | NO): ")
#         if exi.lower() == "yes":
#             break
#         else:
#             continue

#     elif option_of_computer.lower() == user.lower():
#         print(
#             f"Your Choice is {user.capitalize()} & Computer Choice is {option_of_computer.capitalize()}"
#         )
#         print("Draw!")

#         exi = input("Do you want to exit (Yes | NO): ")
#         if exi.lower() == "yes":
#             break
#         else:
#             continue

#     else:
#         print("Invalid input, Try again")
#         continue

# ----------------------------------------------------------------------------------------

# num = int(input("Enter the number: "))

# for i in range(1, 30):
#     print(f"{i} * {num} = {i * num}")

# ----------------------------------------------------------------------------------------

# for i in range(1, 50):
#     if i % 2 == 0:
#         print(i)

# ----------------------------------------------------------------------------------------

word = "hello world"
word = input("Enter the word: ")

lst = []
for i in word:
    if (f"{i} : {word.count(i)}") not in lst:
        lst.append(f"{i} : {word.count(i)}")

for i in lst:
    print(i)
